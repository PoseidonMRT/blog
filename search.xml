<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView Item Animation]]></title>
    <url>%2Fblog%2F2019%2F05%2F06%2Frecycler-item-animation%2F</url>
    <content type="text"><![CDATA[废话不多说，先看动图，今天主要目标就是实现下图效果： 要实现上图中的动画效果，我们主要需要做两件事： 定义子项的动画效果 将子项的动画效果应用到Item上 那么怎么完成上述两部工作呢？子项动画效果当然简单了，就像我们平时的动画效果一样使用Animation Resource资源文件进行定义即可，但是将动画效果绑定到RecyclerView Item上，好像没有听过过方法哎？ 这里我们介绍的基本思路是使用layoutAnimation实现。 layoutAnimation简介关于layoutAnimation，官网的简介是这样的： Defines the layout animation to use the first time the ViewGroup is laid out. Layout animations can also be started manually after the first layout. 从上述描述我们可以看出layoutAnimation是用于指定ViewGroup首次渲染显示时的动画效果，在后续编码过程中也可以手动触发该动画。 layoutAnimation可以直接在xml中定义，常见定义格式如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:animation=&quot;@anim/item_animation_fall_down&quot; android:delay=&quot;15%&quot; android:animationOrder=&quot;normal&quot; /&gt; 其中： animation:指定的是动画资源文件 delay:指定的是动画延时时间 animationOrder:指定的是动画的次序，可取值有normal(从第一项到最后一项开始动画)，random(随机项开始动画)，reverse(从最后一项到第一项开始动画) layoutAnimation使用新建item_animation_fall_down.xml动画资源文件如下： 123456789101112131415161718192021&lt;!-- item_animation_fall_down.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@integer/anim_duration_medium&quot;&gt; &lt;translate android:fromYDelta=&quot;-20%&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:toYDelta=&quot;0&quot;&gt;&lt;/translate&gt; &lt;alpha android:fromAlpha=&quot;0&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:toAlpha=&quot;1&quot;&gt;&lt;/alpha&gt; &lt;scale android:fromXScale=&quot;105%&quot; android:fromYScale=&quot;105%&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toXScale=&quot;100%&quot; android:toYScale=&quot;100%&quot;&gt;&lt;/scale&gt;&lt;/set&gt; 新建layout_animation_fall_down.xml文件，在layoutAnimation中引用该Item动画资源如下： 12345678&lt;!-- layout_animation_fall_down.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:animation=&quot;@anim/item_animation_fall_down&quot; android:delay=&quot;15%&quot; android:animationOrder=&quot;normal&quot; /&gt; 为RecyclerView指定该子项动画资源即可： 12345final Context context = recyclerView.getContext();final LayoutAnimationController layoutAnimationController = AnimationUtils.loadLayoutAnimation(context,R.anim.layout_animation_fall_down);//load layoutAnimation resrecyclerView.setLayoutAnimation(layoutAnimationController);//set layoutAnimationrecyclerView.setLayoutManager(new LinearLayoutManager(this));recyclerView.scheduleLayoutAnimation(); //play animation 运行效果如下，图中子项动画资源为： 12345678910111213141516&lt;!-- item_animation_slide_from_left.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;@integer/anim_duration_medium&quot;&gt; &lt;translate android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:fromXDelta=&quot;-100%p&quot; android:toXDelta=&quot;0&quot; /&gt; &lt;alpha android:fromAlpha=&quot;0.5&quot; android:toAlpha=&quot;1&quot;android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot; /&gt;&lt;/set&gt;]]></content>
      <categories>
        <category>-Android</category>
      </categories>
      <tags>
        <tag>-RecyclerView -Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用首页转场动画实现]]></title>
    <url>%2Fblog%2F2019%2F04%2F26%2F%E5%BA%94%E7%94%A8%E9%A6%96%E9%A1%B5%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Activity作为Android系统中参与用户交互的重要组件，在日常开发过程中，我们经常需要定义Activity跳转动画以便为用户提供更好的体验，那么怎么设置Activity跳转动画呢？在Android系统源码中，预定义了三种相关的转场动画资源文件(文中描述的默认文件都位于AOSP/framework/base/core/res/anim目录下)： Window窗体动画 主要属性说明如下表，均可以通过自定义Theme中的windowAnimationStyle属性来覆写下表中的默认动画。用于指定单个页面打开或关闭动画可使用窗口动画定义，需要注意的是当页面的windowIsTranslucent值为true时，需要通过下面方式来指定窗体动画。 @anim/enter_from_left @anim/out_from_left 动画属性名称 说明 默认动画文件 其他说明 android:windowEnterAnimation 添加窗体时的动画效果 android:windowExitAnimation 移除窗体时的动画效果 android:windowShowAnimation 显示窗体时的动画效果 android:windowHideAnimation 隐藏窗体时的动画效果 栈动画 主要属性说明如下表，均可以通过自定义Theme中的windowAnimationStyle属性来覆写下表中的默认动画。 当我们需要在不同栈之间进行页面切换时，需要使用栈动画。使用过程中需要注意的是在A到B栈之间切换时，B的入动画声明在自己栈顶的第一个页面上，B的出厂动画取决于他的下一个栈中声明的taskOpenExitAnimation属性。 动画属性名称 说明 默认动画文件 其他说明 android:taskOpenEnterAnimation A栈最后一个页面启动B栈第一个页面，B栈第一个页面的入场动画 task_open_exit.xml android:taskOpenExitAnimation A栈最后一个页面的出场动画 task_open_exit.xml android:taskCloseEnterAnimation B栈退出时，下一个栈的入场动画 task_close_enter.xml android:taskCloseExitAnimation B栈退出时，当前页面的退场动画 task_close_exit.xml android:taskToFrontEnterAnimation 一个已有栈切换到前台时，该栈的动画效果 task_open_exit.xml android:taskToFrontExitAnimation 一个已有栈切换到前台时，当前前台栈的动画效果 task_open_exit.xml android:taskToBackEnterAnimation 进入后台时，切换到前台栈的入场动画效果 task_close_enter.xml android:taskToBackExitAnimation 进入到后台时，当前在前台即将进入后台的动画效果 task_close_exit.xml Activity动画 主要属性说明如下表，均可以通过自定义Theme中的windowAnimationStyle属性来覆写下表中的默认动画。当我们需要在同一栈内的Activty之间进行页面切换时，需要使用Activity动画。使用过程中需要注意的是在A到B Activity之间切换时，B的入场动画声明在自己Style文件中，B的出厂动画取决于他的下一个Activity中声明的activityOpenExitAnimation属性。 动画属性名称 说明 默认动画文件 其他说明 android:activityOpenEnterAnimation A-B时，B activity的入场动画 activity_open_enter.xml android:activityOpenExitAnimation A Activity的出厂动画 activivty_open_exit.xml android:activityCloseEnterAnimation B-C时，C activity的入场动画 activivty_close_enter.xml android:activityCloseExitAnimation B Activity的出场动画 activivty_close_exit.xml 如果日常开发过程中我们需要指定各页面的转场动画，只需要新建Theme，覆写上面描述的动画资源attr即可。 比如我们要定制SettingsActivity的转场动画，我们只需要这样编写代码： 1.定义Settings Theme，覆写windowAnimationStyle属性 123&lt;style name="SettingsActivityTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/SettingsWindowAnimationStyle&lt;/item&gt;&lt;/style&gt; 2.定义windowAnimationStyle属性引用的style 12345678910111213&lt;style name="SettingsWindowAnimationStyle" parent="@android:style/Animation.Activity"&gt; &lt;!-- A-B时，启动新页面 --&gt; &lt;!-- 即将打开的activity的进入动画 B的入场动画--&gt; &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/enter_from_right&lt;/item&gt; &lt;!-- 当前Activity的退场动画 A的出厂动画--&gt; &lt;item name="android:activityOpenExitAnimation"&gt;@anim/out_from_right&lt;/item&gt; &lt;!-- B-C时，返回 --&gt; &lt;!-- 下一个activity的进入动画 C的入场动画--&gt; &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/enter_from_right&lt;/item&gt; &lt;!-- 当前Activity的推出动画 B的出场动画--&gt; &lt;item name="android:activityCloseExitAnimation"&gt;@anim/out_from_right&lt;/item&gt;&lt;/style&gt; 这里需要注意的是在 Activity和栈动画，parent需是@android:style/Animation.Activity Window窗体动画属性，parent一般不写，当windowIsTranslucent为true时，其parent需是@android:style/Animation.Translucent 3.在AndroidManifest.xml文件中引用第一步中定义的Theme即可 1234&lt;activity android:name=".SettingsActivity" android:theme="@style/SettingsActivityTheme"&gt;&lt;/activity&gt; 特殊情况说明 同栈内A-&gt;B-&gt;C跳转时，B的入场动画及A的退场动画由B的style文件指定，C的入场动画以及B的出厂动画由C的style文件指定，以此类推 A页面到B页面，B页面的启动模式为SingleInstance，此时需要使用栈动画来指定A到B的跳转动画 桌面到应用启动页，此时需要用栈动画，但是由于没办法在修改launcher应用代码，会使得入场动画有效，但是启动页退场动画无效，此时可以通过下述代码强制指定退出动画 1234override fun finish() &#123; super.finish() overridePendingTransition(0,R.anim.out_from_left)&#125; 当然在桌面到应用启动页这种情形下也可以使用Window窗体动画来指定动画效果，但会产生黑屏问题，此时我们可以通过设置windowIsTranslucent属性为true的方式来解决，具体代码如下： 12345678&lt;style name="MainActivityTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/TranslucentWindow&lt;/item&gt;&lt;/style&gt; &lt;style name="TranslucentWindow" parent="@android:style/Animation.Translucent"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/enter_from_left&lt;/item&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/out_from_left&lt;/item&gt;&lt;/style&gt; 此时同样需要在代码中指定退出动画： 1234override fun finish() &#123; super.finish() overridePendingTransition(0,R.anim.out_from_left)&#125; 参考资料Activity切换动画无效[https://blog.csdn.net/wjr1949/article/details/72643798]]]></content>
      <categories>
        <category>-Android</category>
      </categories>
      <tags>
        <tag>-Activity -Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter Todo App(1)]]></title>
    <url>%2Fblog%2F2019%2F04%2F19%2FFlutter-Todo-App-1%2F</url>
    <content type="text"><![CDATA[Flutter todo app]]></content>
      <categories>
        <category>-Flutter</category>
      </categories>
      <tags>
        <tag>-Flutter -async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View简介]]></title>
    <url>%2Fblog%2F2019%2F04%2F01%2FView%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[View是什么要学习自定义View，我们首先应该清楚的认识到View是个什么东西。那么View究竟是什么呢？ 从代码层面看，View是一个类，是所有控件的直接或间接父类，详情见图-View子孙关系，图中只显示了部分View的子孙，有兴趣的朋友可以尝试自己去画下这幅图 从用户角度看，View是用户界面的组成元素，View参与用户交互 那么View究竟长什么样呢？见图-View界面边界 从上图可以看出(开发者选项-&gt;打开布局边界)，界面上框出了很多大小不一的矩形框，我们可以把这里的每一个框都看作一个View或一个View子孙类，在Android Studio中打开布局管理器，也能看到类似于这种效果，如图-Android Studio View界面边界。 通过上面描述，我们可以清晰的认识到，View对应着界面上的一块矩形区域，在这块矩形区域内可以进行用户交互，那么这个矩形区域内部各种各样的颜色，Icon又是怎么显示出来的呢？ View生命周期我们都知道Android中大多数控件具有生命周期敏感性，那么View有没有生命周期呢？答案是肯定的，View作为用户交互的重要组成元素，与Activity一样具有显式生命周期，只不过一般我们不去过分强调而已。 如图-View生命周期所示，其中描述了View的整个生命周期过程，其中我们需要关注r如下几点: invalidate()的同作用函数postInvalidate()，两者均用于更新View内容，只不过postInvalidate()发生在单独的线程，invalidate()发生在主线程； View整个生命周期中有四个重要函数，构造器从XML文件中解析View属性，onMeasure()测量View大小，测量过程与测量模式，Padding，Margin等有关， onLayout()完成View的位置布局,onDraw()完成View内容的绘制; 如上图所示，如果需要View重新计算大小，则需要调用requestLayout(),启动View的深度优先遍历过程，重新构造View树，关于View树的相关信息，我们会在后续文章中描述; 上图中并没有绘制View 触屏事件相关的响应函数，会在随后的View事件处理部分进行详细描述; View坐标系不知道大家是否还记得我们学习绘制图形之前，最开始学习的是什么？相信大多数朋友都知道那就是坐标系，对于在View上绘制图形也是一样，首先需要要绘制图形在View内的位置，随后才能使用画笔进行绘制，那么View内部坐标系是怎样的呢？ 如图-View坐标系所示，View内部的坐标原点位于View所在矩形的左上角，以屏幕水平右方向为X轴正向，以垂直向下方向为Y轴正向，那么我们经常使用的View#getTop(),View#getLeft(),View#getBottom(),View#getRight()等返回的又是哪里的距离呢？ 具体的函数值说明，如图-View函数值说明所示，大家自行参考。 View事件处理View作为参与用户交互的重要元素之一，响应用户操作必不可少，View内部的事件分发机制如图-View内部分发流程。 从上图所示 ，在View内部事件分发过程中，事件起始于父控件调用dispatchTouchEvent,止于onTouchListener或者onTouchEvent返回true(true-事件被消耗，false-未消耗事件)，如果onTouchListener返回false或为空，事件会进一步传递到onTouchEvent处理，如果onTouchEvent返回false，事件会被扔回父控件处理，如果每级都按照上述流程返回false，则事件会被上传到操作系统抛弃掉。 现有状况下我们一般有两种方式处理用户事件： 重写View#onTouchEvent() View onTouchListener接口 那么这两种处理方式有什么区别呢？从下面源码中我们可以看出onTouchListener的优先与onTouchEvent，所以在重写onTouchEvent无效的情况下，除了check 父控件是否向下分发事件以外，还需要check该控件是否有onTouchListener的监听。 123456789101112131415161718192021222324252627282930313233343536373839404142/** Android P 源码代码片段 **/public boolean dispatchTouchEvent(MotionEvent event) &#123; .... if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //优先响应onTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //onTouchListener为空或者返回false时，响应onTouchEvent if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125;]]></content>
      <categories>
        <category>-Android</category>
      </categories>
      <tags>
        <tag>-View -TouchEvent</tag>
      </tags>
  </entry>
</search>
